# Sprint 4, Story 8.4: Create Walking Skeleton Services

## Story Summary
Create minimal microservices that prove the architecture works end-to-end.

**What We're Building:**
- Frontend (React/Node)
- API Gateway (Node.js)
- Product Service (Node.js)
- Order Service (Python)

---

## Prerequisites
- S8.1-8.3 completed (ECR, Dockerfiles, Helm)
- Local Node.js and Python installed

---

## Part 1: Monorepo Structure

### Step 1.1: Create Directory Structure
```bash
cd ~/Desktop/Devops-Project/techitfactory-app

mkdir -p services/{frontend,api-gateway,product-service,order-service,user-service}
```

### Step 1.2: Final Structure
```
techitfactory-app/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ frontend/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ nginx.conf
â”‚   â”œâ”€â”€ api-gateway/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â”œâ”€â”€ product-service/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â”œâ”€â”€ order-service/
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â””â”€â”€ requirements.txt
â”‚   â””â”€â”€ user-service/
â”‚       â”œâ”€â”€ src/
â”‚       â”œâ”€â”€ Dockerfile
â”‚       â””â”€â”€ package.json
â”œâ”€â”€ charts/
â”‚   â””â”€â”€ microservice/
â””â”€â”€ .github/
    â””â”€â”€ workflows/
```

---

## Part 2: API Gateway (Node.js)

### Step 2.1: package.json
```json
{
  "name": "api-gateway",
  "version": "1.0.0",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "axios": "^1.6.0",
    "prom-client": "^15.0.0",
    "winston": "^3.11.0"
  }
}
```

### Step 2.2: src/index.js
```javascript
const express = require('express');
const axios = require('axios');
const client = require('prom-client');
const winston = require('winston');

const app = express();
const PORT = process.env.PORT || 3000;

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [new winston.transports.Console()]
});

// Metrics
const collectDefaultMetrics = client.collectDefaultMetrics;
collectDefaultMetrics();

const httpRequestsTotal = new client.Counter({
  name: 'http_requests_total',
  help: 'Total HTTP requests',
  labelNames: ['method', 'path', 'status']
});

// Middleware
app.use(express.json());
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    httpRequestsTotal.inc({ method: req.method, path: req.path, status: res.statusCode });
    logger.info({ method: req.method, path: req.path, status: res.statusCode, duration: Date.now() - start });
  });
  next();
});

// Health endpoints
app.get('/health', (req, res) => res.json({ status: 'healthy' }));
app.get('/ready', (req, res) => res.json({ status: 'ready' }));

// Metrics endpoint
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', client.register.contentType);
  res.end(await client.register.metrics());
});

// API Routes
app.get('/api/products', async (req, res) => {
  try {
    const response = await axios.get(`${process.env.PRODUCT_SERVICE_URL || 'http://product-service'}/products`);
    res.json(response.data);
  } catch (error) {
    logger.error({ message: 'Product service error', error: error.message });
    res.status(503).json({ error: 'Product service unavailable' });
  }
});

app.get('/api/orders', async (req, res) => {
  try {
    const response = await axios.get(`${process.env.ORDER_SERVICE_URL || 'http://order-service'}/orders`);
    res.json(response.data);
  } catch (error) {
    logger.error({ message: 'Order service error', error: error.message });
    res.status(503).json({ error: 'Order service unavailable' });
  }
});

app.listen(PORT, () => {
  logger.info({ message: `API Gateway listening on port ${PORT}` });
});
```

---

## Part 3: Product Service (Node.js)

### Step 3.1: src/index.js
```javascript
const express = require('express');
const client = require('prom-client');

const app = express();
const PORT = process.env.PORT || 3000;

collectDefaultMetrics = client.collectDefaultMetrics;
collectDefaultMetrics();

// Mock data
const products = [
  { id: 1, name: 'Laptop', price: 999.99, category: 'Electronics' },
  { id: 2, name: 'Headphones', price: 149.99, category: 'Electronics' },
  { id: 3, name: 'Coffee Maker', price: 79.99, category: 'Kitchen' }
];

app.get('/health', (req, res) => res.json({ status: 'healthy' }));
app.get('/ready', (req, res) => res.json({ status: 'ready' }));
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', client.register.contentType);
  res.end(await client.register.metrics());
});

app.get('/products', (req, res) => {
  res.json({ products, count: products.length });
});

app.get('/products/:id', (req, res) => {
  const product = products.find(p => p.id === parseInt(req.params.id));
  if (!product) return res.status(404).json({ error: 'Product not found' });
  res.json(product);
});

app.listen(PORT, () => console.log(`Product Service on port ${PORT}`));
```

---

## Part 4: Order Service (Python)

### Step 4.1: requirements.txt
```
flask==3.0.0
gunicorn==21.2.0
prometheus_client==0.19.0
```

### Step 4.2: app/main.py
```python
from flask import Flask, jsonify
from prometheus_client import Counter, generate_latest, CONTENT_TYPE_LATEST

app = Flask(__name__)

# Metrics
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'path', 'status'])

# Mock data
orders = [
    {'id': 1, 'product_id': 1, 'quantity': 2, 'status': 'pending'},
    {'id': 2, 'product_id': 3, 'quantity': 1, 'status': 'shipped'}
]

@app.route('/health')
def health():
    return jsonify({'status': 'healthy'})

@app.route('/ready')
def ready():
    return jsonify({'status': 'ready'})

@app.route('/metrics')
def metrics():
    return generate_latest(), 200, {'Content-Type': CONTENT_TYPE_LATEST}

@app.route('/orders')
def get_orders():
    REQUEST_COUNT.labels(method='GET', path='/orders', status='200').inc()
    return jsonify({'orders': orders, 'count': len(orders)})

@app.route('/orders/<int:order_id>')
def get_order(order_id):
    order = next((o for o in orders if o['id'] == order_id), None)
    if not order:
        REQUEST_COUNT.labels(method='GET', path=f'/orders/{order_id}', status='404').inc()
        return jsonify({'error': 'Order not found'}), 404
    REQUEST_COUNT.labels(method='GET', path=f'/orders/{order_id}', status='200').inc()
    return jsonify(order)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)
```

---

## Part 5: Frontend (React + Nginx)

### Step 5.1: Simple HTML (for demo)
```html
<!DOCTYPE html>
<html>
<head>
  <title>TechITFactory</title>
  <style>
    body { font-family: Arial; margin: 40px; background: #1a1a2e; color: #eee; }
    h1 { color: #00d9ff; }
    .card { background: #16213e; padding: 20px; margin: 10px 0; border-radius: 8px; }
  </style>
</head>
<body>
  <h1>TechITFactory Platform</h1>
  <div class="card">
    <h2>Products</h2>
    <div id="products">Loading...</div>
  </div>
  <div class="card">
    <h2>Orders</h2>
    <div id="orders">Loading...</div>
  </div>
  <script>
    fetch('/api/products').then(r => r.json()).then(d => {
      document.getElementById('products').innerHTML = 
        d.products.map(p => `<p>${p.name} - $${p.price}</p>`).join('');
    });
    fetch('/api/orders').then(r => r.json()).then(d => {
      document.getElementById('orders').innerHTML = 
        d.orders.map(o => `<p>Order #${o.id} - ${o.status}</p>`).join('');
    });
  </script>
</body>
</html>
```

### Step 5.2: nginx.conf
```nginx
server {
    listen 80;
    server_name _;
    
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
    }
    
    location /health {
        return 200 '{"status":"healthy"}';
        add_header Content-Type application/json;
    }
    
    location /ready {
        return 200 '{"status":"ready"}';
        add_header Content-Type application/json;
    }
}
```

---

## Part 6: End-to-End Test

### Deploy All Services
```bash
# Apply via ArgoCD or kubectl
kubectl apply -f environments/dev/

# Check pods
kubectl get pods -n techitfactory

# Test endpoints
kubectl port-forward svc/api-gateway 3000:80 -n techitfactory
curl http://localhost:3000/api/products
curl http://localhost:3000/api/orders
```

---

## Story Completion Checklist
- [ ] Monorepo structure created
- [ ] API Gateway with routing
- [ ] Product Service with mock data
- [ ] Order Service (Python)
- [ ] Frontend with basic UI
- [ ] All services have /health, /ready, /metrics
- [ ] All Dockerfiles are multi-stage, non-root
- [ ] End-to-end test works

---

## Epic 8 Complete! ðŸŽ‰

**Walking Skeleton Proves:**
- Docker builds work
- ECR push works
- Helm charts deploy correctly
- Services communicate
- Ingress routes traffic
- Monitoring captures metrics/logs

**Next: Epic 9 (CI/CD Pipeline)**
