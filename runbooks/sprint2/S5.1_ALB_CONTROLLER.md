# Sprint 2, Story 5.1: Deploy Application with Ingress

## Story Summary
Deploy a sample application and expose it via AWS ALB Ingress.

---

## Why Are We Doing This?

**The Problem:**
You have an app running in Kubernetes, but nobody outside can access it. Pods have internal IPs only.

**The Solution Options:**
| Option | How It Works | Best For |
|--------|--------------|----------|
| NodePort | Opens port on every node | Testing only |
| LoadBalancer (Service) | Creates AWS NLB | Single service |
| **Ingress (ALB)** | Routes HTTP/HTTPS to services | Production apps |

**Why Ingress + ALB?**
- Single ALB for multiple services (cost efficient)
- Path-based routing: `/api` → backend, `/` → frontend
- HTTPS termination with ACM certificates
- Health checks, sticky sessions, WAF integration

---

## Runbook Overview

| Part | What We're Doing | Why |
|------|------------------|-----|
| 0 | Verify ALB Controller | Can't create Ingress without it |
| 1 | Deploy sample app | Need something to expose |
| 2 | Create Ingress | Tells K8s what traffic routing we want |
| 3 | Test access | Prove it works |

---

## Part 0: Verify Prerequisites

### Step 0.1: Check ALB Controller is Running
```bash
kubectl get pods -n kube-system | grep aws-load-balancer
# Should show 2/2 Running

kubectl get deployment aws-load-balancer-controller -n kube-system
```

**If not installed, go back to S4.4 first!**

### Step 0.2: Check IngressClass Exists
```bash
kubectl get ingressclass
# Should show "alb" class
```

If missing:
```bash
kubectl apply -f - <<EOF
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: alb
  annotations:
    ingressclass.kubernetes.io/is-default-class: "true"
spec:
  controller: ingress.k8s.aws/alb
EOF
```

---

## Part 1: Deploy Sample Application

### Why This Application?

We're using `http-echo` - a tiny app that just returns text. Perfect for testing because:
- Doesn't need database
- Returns custom message (proves it's your app)
- Tiny image (2MB)

### Step 1.1: Create Deployment
```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: hello-app
  template:
    metadata:
      labels:
        app: hello-app
    spec:
      containers:
      - name: hello
        image: hashicorp/http-echo
        args:
          - "-text=Hello from TechITFactory!"
        ports:
        - containerPort: 5678
EOF
```

**What this creates:**
- 2 pods running http-echo
- Each pod listens on port 5678
- Returns "Hello from TechITFactory!" on any request

### Step 1.2: Create Service
```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: hello-app
spec:
  selector:
    app: hello-app
  ports:
  - port: 80
    targetPort: 5678
EOF
```

**What this creates:**
- ClusterIP service (internal only)
- Maps external port 80 → pod port 5678
- Ingress will use this to reach pods

### Step 1.3: Verify Pods Running
```bash
kubectl get pods -l app=hello-app
# Both should be Running

kubectl get service hello-app
# Should show ClusterIP
```

---

## Part 2: Create Ingress to Expose Application

### Understanding Ingress Annotations

| Annotation | Why We Use It |
|------------|---------------|
| `scheme: internet-facing` | Create public ALB (vs internal) |
| `target-type: ip` | Route directly to pod IPs (faster) |
| `healthcheck-path` | ALB checks this path for health |

### Step 2.1: Create Ingress
```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hello-app
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/healthcheck-path: /
spec:
  ingressClassName: alb
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: hello-app
            port:
              number: 80
EOF
```

**What happens now:**
1. ALB Controller sees this Ingress
2. Creates ALB in AWS (takes 2-3 min)
3. Creates Target Group
4. Registers pod IPs as targets
5. Updates Ingress with ALB DNS

---

## Part 3: Test the Application

### Step 3.1: Watch ALB Creation
```bash
kubectl get ingress hello-app -w
# Wait for ADDRESS to populate
```

### Step 3.2: Get ALB URL
```bash
ALB_URL=$(kubectl get ingress hello-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
echo "Your app is at: http://$ALB_URL"
```

### Step 3.3: Test Access
```bash
curl http://$ALB_URL
# Should return: Hello from TechITFactory!
```

### Step 3.4: Verify in AWS Console
1. Go to **EC2** → **Load Balancers**
2. Find ALB with name like `k8s-default-helloapp-xxx`
3. Check **Target Groups** → Targets should be healthy

---

## Part 4: Cleanup (Optional)

```bash
kubectl delete ingress hello-app
kubectl delete service hello-app
kubectl delete deployment hello-app

# ALB will be deleted automatically (~2 min)
```

---

## Troubleshooting

### ALB Not Creating
```bash
# Check controller logs
kubectl logs deployment/aws-load-balancer-controller -n kube-system | grep -i error

# Common issues:
# - Subnets don't have kubernetes.io/role/elb=1 tag
# - IRSA not working
```

### Targets Unhealthy
```bash
# Check pod health
kubectl get pods -l app=hello-app

# Check healthcheck path works
kubectl port-forward service/hello-app 8080:80
curl http://localhost:8080/
```

---

## Key Takeaways

1. **Ingress = Routing rules** → tells K8s what we want
2. **ALB Controller = Implementation** → actually creates AWS resources
3. **Annotations control behavior** → scheme, target-type, SSL, etc.
4. **One ALB can serve multiple apps** → path-based routing saves money

---

## Cost Note

| Resource | When Created | Monthly Cost |
|----------|--------------|--------------|
| ALB | When Ingress created | ~$16 base + usage |
| ALB | When Ingress deleted | $0 (auto-cleanup) |

**Tip:** Don't leave test Ingresses running - delete when done!

---

## Next: Story 5.2 (Route53 + TLS)
