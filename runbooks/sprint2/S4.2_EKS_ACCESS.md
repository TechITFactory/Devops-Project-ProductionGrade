# Sprint 2, Story 4.2: Configure EKS Access

## Story Summary
Configure IAM authentication for EKS cluster access using the modern EKS Access Entry API.

**What We're Configuring:**
- EKS Access Entry for cluster admin
- Understanding aws-auth ConfigMap (legacy)
- Read-only access for developers

> **ðŸ†• EKS Access Entry** is the modern approach (2023+). It's managed via Terraform/AWS API instead of editing ConfigMaps.

---

## Prerequisites
- S4.1 completed (EKS cluster running)
- kubectl configured and working

---

## Part 0: Verify Prerequisites

### Step 0.1: Verify EKS is Running
```bash
cd ~/Desktop/Devops-Project/techitfactory-infra/environments/dev

# Check cluster name
terraform output cluster_name

# Verify kubectl works
kubectl get nodes
# Should show nodes in Ready state
```

### Step 0.2: Get Current User Info
```bash
# Who am I?
aws sts get-caller-identity

# Note your ARN - you'll use it for access configuration
```

---

## Part 1: Understanding EKS Authentication

### Authentication Flow
```
User â†’ AWS IAM/SSO â†’ EKS Access API â†’ Kubernetes RBAC
     |               |                |
     Auth identity   Maps IAMâ†’K8s     Grants permissions
```

### Two Approaches:

| Approach | Managed Via | Recommended |
|----------|-------------|-------------|
| **EKS Access Entry** (new) | Terraform/API | âœ… Yes |
| aws-auth ConfigMap (legacy) | kubectl edit | âŒ Legacy |

> **Why EKS Access Entry?**
> - Managed declaratively in Terraform
> - No kubectl access required to grant access
> - Better for SSO/IAM Identity Center

---

## Part 2: Check Current Access

### Step 2.1: View Current aws-auth ConfigMap
```bash
kubectl get configmap aws-auth -n kube-system -o yaml

# You'll see the node role mapped:
# mapRoles:
#   - rolearn: arn:aws:iam::ACCOUNT:role/techitfactory-dev-node-role
#     username: system:node:{{EC2PrivateDNSName}}
#     groups:
#       - system:bootstrappers
#       - system:nodes
```

### Step 2.2: Check Who Can Access
```bash
# Your current identity
kubectl auth whoami
# or
kubectl auth can-i get pods
```

---

## Part 3: Add Access via EKS Access Entry (Recommended)

### Step 3.1: Add Access Entry in Terraform

Add this to your EKS module or dev environment:

```bash
cd ~/Desktop/Devops-Project/techitfactory-infra/environments/dev

# Add to main.tf (after the EKS module):
cat >> main.tf << 'EOF'

# =============================================================================
# EKS ACCESS ENTRIES
# =============================================================================

# Admin access for current user/role
resource "aws_eks_access_entry" "admin" {
  cluster_name  = module.eks.cluster_name
  principal_arn = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:user/YOUR_USERNAME"
  type          = "STANDARD"
}

resource "aws_eks_access_policy_association" "admin" {
  cluster_name  = module.eks.cluster_name
  principal_arn = aws_eks_access_entry.admin.principal_arn
  policy_arn    = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"

  access_scope {
    type = "cluster"
  }
}

data "aws_caller_identity" "current" {}
EOF
```

### Step 3.2: Update with Your Username
```bash
# Replace YOUR_USERNAME with your actual IAM username
nano main.tf

# Or use sed (replace 'jai' with your username):
# sed -i 's/YOUR_USERNAME/jai/g' main.tf
```

### Step 3.3: Apply Changes
```bash
terraform plan
# Should show 2-3 new resources (access entry + policy association)

terraform apply
```

---

## Part 4: Add Access via aws-auth ConfigMap (Legacy)

> **Use this only if you prefer the legacy approach or need backward compatibility.**

### Step 4.1: Using eksctl (Easiest)
```bash
# Install eksctl if not installed
# brew install eksctl (Mac) or see https://eksctl.io/installation/

# Add IAM user as admin
eksctl create iamidentitymapping \
  --cluster techitfactory-dev \
  --region ap-south-1 \
  --arn arn:aws:iam::ACCOUNT:user/YOUR_USERNAME \
  --username admin \
  --group system:masters

# Add IAM role
eksctl create iamidentitymapping \
  --cluster techitfactory-dev \
  --region ap-south-1 \
  --arn arn:aws:iam::ACCOUNT:role/AdminRole \
  --username admin \
  --group system:masters
```

### Step 4.2: Manual Edit (Alternative)
```bash
kubectl edit configmap aws-auth -n kube-system

# Add under mapUsers:
# mapUsers: |
#   - userarn: arn:aws:iam::ACCOUNT:user/YOUR_USERNAME
#     username: admin
#     groups:
#       - system:masters
```

---

## Part 5: Create Developer Read-Only Access

### Step 5.1: Create Read-Only ClusterRole
```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: developer-readonly
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps", "namespaces", "events"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets", "statefulsets", "daemonsets"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["pods/log"]
  verbs: ["get", "list"]
- apiGroups: ["networking.k8s.io"]
  resources: ["ingresses"]
  verbs: ["get", "list", "watch"]
EOF
```

### Step 5.2: Create ClusterRoleBinding for developers Group
```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: developer-readonly-binding
subjects:
- kind: Group
  name: developers
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: developer-readonly
  apiGroup: rbac.authorization.k8s.io
EOF
```

### Step 5.3: Map Developer IAM Role (via Access Entry)
```bash
# Add to main.tf:
cat >> main.tf << 'EOF'

# Developer read-only access (example)
# resource "aws_eks_access_entry" "developer" {
#   cluster_name  = module.eks.cluster_name
#   principal_arn = "arn:aws:iam::ACCOUNT:role/DeveloperRole"
#   type          = "STANDARD"
#   kubernetes_groups = ["developers"]
# }
EOF
```

---

## Part 6: Verification

### Step 6.1: Test Admin Access
```bash
# Should return yes
kubectl auth can-i create pods
kubectl auth can-i delete namespaces
```

### Step 6.2: List Access Entries
```bash
aws eks list-access-entries --cluster-name techitfactory-dev
```

### Step 6.3: Describe Access Entry
```bash
aws eks describe-access-entry \
  --cluster-name techitfactory-dev \
  --principal-arn "arn:aws:iam::ACCOUNT:user/YOUR_USERNAME"
```

### Step 6.4: View aws-auth ConfigMap
```bash
kubectl get configmap aws-auth -n kube-system -o yaml
```

---

## Commit and Push

```bash
cd ~/Desktop/Devops-Project/techitfactory-infra
git add .
git commit -m "Configure EKS access entries"
git push origin main
```

---

## Story Completion Checklist
- [ ] EKS cluster access verified (kubectl get nodes)
- [ ] Authentication methods understood
- [ ] Admin access configured (Access Entry or aws-auth)
- [ ] Developer ClusterRole created
- [ ] Developer ClusterRoleBinding created
- [ ] Access verified
- [ ] Changes committed

---

## Access Policy Reference

| Policy | Use Case |
|--------|----------|
| AmazonEKSClusterAdminPolicy | Full cluster admin |
| AmazonEKSAdminPolicy | Namespace admin |
| AmazonEKSEditPolicy | Edit resources |
| AmazonEKSViewPolicy | Read-only |

---

## Next: Story 4.3 (Cluster Autoscaler)
