# Sprint 2, Story 4.2: Configure EKS Access

## Story Summary
Configure IAM authentication for EKS cluster access using the modern EKS Access Entry API.

**What We're Configuring:**
- EKS Access Entry for cluster admin
- Understanding aws-auth ConfigMap (legacy)
- Kubernetes RBAC for developer access

> **ðŸ†• EKS Access Entry** is the modern approach (2023+). It's managed via Terraform/AWS API instead of editing ConfigMaps.

---

## Prerequisites
- S4.1 completed (EKS cluster running)
- kubectl configured and working

---

## Part 0: Verify Prerequisites

### Step 0.1: Verify EKS is Running
```bash
cd ~/Desktop/Devops-Project/techitfactory-infra/environments/dev

# Check cluster name
terraform output cluster_name
# Output: "techitfactory-dev"

# Verify kubectl works
kubectl get nodes
# Should show 2 nodes in Ready state
```

### Step 0.2: Get Current User Info
```bash
# Who am I?
aws sts get-caller-identity

# Note your ARN - you'll use it for access configuration
# Example: arn:aws:iam::123456789012:user/jai
```

---

## Part 1: Understanding EKS Authentication

### The Authentication Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     EKS Authentication                              â”‚
â”‚                                                                     â”‚
â”‚  1. User/Role        2. AWS IAM           3. Kubernetes             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ IAM User â”‚â”€â”€â”€â”€â”€â”€â–¶â”‚ EKS Access   â”‚â”€â”€â”€â”€â–¶â”‚ Kubernetes RBAC      â”‚  â”‚
â”‚  â”‚ or Role  â”‚       â”‚ Entry API    â”‚     â”‚ (ClusterRole, etc.)  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                      â”‚
â”‚                     Maps IAM â†’ K8s user                             â”‚
â”‚                     + assigns K8s groups                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Two Parts to Access:**
1. **Authentication (Who are you?)** â†’ IAM identity verified by AWS
2. **Authorization (What can you do?)** â†’ Kubernetes RBAC grants permissions

---

## Part 2: Two Approaches to EKS Access

### Comparison

| Feature | EKS Access Entry (New) | aws-auth ConfigMap (Legacy) |
|---------|------------------------|----------------------------|
| Managed Via | Terraform/AWS API | kubectl edit |
| Requires kubectl | No | Yes |
| SSO Support | âœ… Native | âš ï¸ Requires setup |
| Declarative | âœ… Yes | âŒ Imperative |
| IAM console | âœ… Shows access | âŒ Hidden in ConfigMap |

**Our recommendation:** Use **EKS Access Entry** for new clusters

### How aws-auth Works (Legacy)
```yaml
# In ConfigMap aws-auth (kube-system namespace)
mapRoles: |
  - rolearn: arn:aws:iam::ACCOUNT:role/node-role
    username: system:node:{{EC2PrivateDNSName}}
    groups:
      - system:bootstrappers
      - system:nodes
mapUsers: |
  - userarn: arn:aws:iam::ACCOUNT:user/jai
    username: admin
    groups:
      - system:masters    # ðŸ‘ˆ Full cluster admin
```

**Problem:** If you lose kubectl access, you can't grant access!

### How EKS Access Entry Works (Modern)
```hcl
# In Terraform - no kubectl needed!
resource "aws_eks_access_entry" "admin" {
  cluster_name  = "techitfactory-dev"
  principal_arn = "arn:aws:iam::ACCOUNT:user/jai"
  type          = "STANDARD"
}

resource "aws_eks_access_policy_association" "admin" {
  cluster_name  = "techitfactory-dev"
  principal_arn = "arn:aws:iam::ACCOUNT:user/jai"
  policy_arn    = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"
  
  access_scope {
    type = "cluster"  # ðŸ‘ˆ Full cluster access
  }
}
```

**Benefit:** Even if kubectl is broken, you can fix access via AWS console/Terraform!

---

## Part 3: Check Current Access

### Step 3.1: View aws-auth ConfigMap
```bash
kubectl get configmap aws-auth -n kube-system -o yaml

# You'll see the node role already mapped:
# mapRoles:
#   - rolearn: arn:aws:iam::ACCOUNT:role/techitfactory-dev-node-role
#     username: system:node:{{EC2PrivateDNSName}}
#     groups:
#       - system:bootstrappers
#       - system:nodes
```

**Why is node role there?** 
- Nodes need to register with the cluster
- `system:bootstrappers` allows initial node setup
- `system:nodes` grants node-level permissions

### Step 3.2: Check Your Current Permissions
```bash
# Check if you can create pods
kubectl auth can-i create pods
# yes (if you're cluster creator)

# Check if you can delete namespaces
kubectl auth can-i delete namespaces
# yes (if you're cluster admin)

# Check your identity
kubectl auth whoami
```

---

## Part 4: Add Admin Access via EKS Access Entry

### Step 4.1: Add to Terraform

Add this to `environments/dev/main.tf`:

```bash
cd ~/Desktop/Devops-Project/techitfactory-infra/environments/dev

# Add to main.tf (after the EKS module):
cat >> main.tf << 'EOF'

# =============================================================================
# EKS ACCESS ENTRIES
# =============================================================================

data "aws_caller_identity" "current" {}

# Admin access for current user
resource "aws_eks_access_entry" "admin" {
  cluster_name  = module.eks.cluster_name
  principal_arn = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:user/YOUR_USERNAME"
  type          = "STANDARD"
}

resource "aws_eks_access_policy_association" "admin" {
  cluster_name  = module.eks.cluster_name
  principal_arn = aws_eks_access_entry.admin.principal_arn
  policy_arn    = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"

  access_scope {
    type = "cluster"  # Full cluster access
  }
}
EOF
```

### Step 4.2: Update with Your Username
```bash
# Replace YOUR_USERNAME with your actual IAM username
# Option 1: Use nano
nano main.tf

# Option 2: Use sed (replace 'jai' with your username)
sed -i 's/YOUR_USERNAME/jai/g' main.tf
```

### Step 4.3: Understanding the Code

```hcl
resource "aws_eks_access_entry" "admin" {
  cluster_name  = module.eks.cluster_name
  principal_arn = "arn:aws:iam::ACCOUNT:user/jai"  # ðŸ‘ˆ IAM user/role ARN
  type          = "STANDARD"                        # ðŸ‘ˆ Standard user access
}
```

**Access Entry Types:**
| Type | Use Case |
|------|----------|
| `STANDARD` | Regular users/roles |
| `EC2_LINUX` | EC2 instances (nodes) |
| `FARGATE_LINUX` | Fargate pods |

```hcl
resource "aws_eks_access_policy_association" "admin" {
  cluster_name  = module.eks.cluster_name
  principal_arn = aws_eks_access_entry.admin.principal_arn
  policy_arn    = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"

  access_scope {
    type = "cluster"       # ðŸ‘ˆ Applies to whole cluster
    # OR
    # type = "namespace"
    # namespaces = ["dev", "staging"]  # ðŸ‘ˆ Only specific namespaces
  }
}
```

**AWS EKS Access Policies:**
| Policy | Permissions |
|--------|-------------|
| `AmazonEKSClusterAdminPolicy` | Full admin (system:masters) |
| `AmazonEKSAdminPolicy` | Admin without RBAC management |
| `AmazonEKSEditPolicy` | Edit resources |
| `AmazonEKSViewPolicy` | Read-only |

### Step 4.4: Apply Changes
```bash
terraform plan
# Should show 2-3 new resources

terraform apply
```

---

## Part 5: Create Developer Read-Only Access

### Step 5.1: Understanding RBAC

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Kubernetes RBAC                                  â”‚
â”‚                                                                     â”‚
â”‚  ClusterRole (defines permissions)                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ developer-readonly:                                           â”‚   â”‚
â”‚  â”‚   pods: [get, list, watch]                                   â”‚   â”‚
â”‚  â”‚   deployments: [get, list, watch]                            â”‚   â”‚
â”‚  â”‚   services: [get, list, watch]                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â”‚                                      â”‚
â”‚                              â–¼                                      â”‚
â”‚  ClusterRoleBinding (grants to groups/users)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ subjects: [Group: developers]                                â”‚   â”‚
â”‚  â”‚ roleRef: developer-readonly                                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Step 5.2: Create Read-Only ClusterRole
```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: developer-readonly
rules:
# Core resources - read only
- apiGroups: [""]
  resources: ["pods", "services", "configmaps", "namespaces", "events", "persistentvolumeclaims"]
  verbs: ["get", "list", "watch"]

# Workload resources - read only
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets", "statefulsets", "daemonsets"]
  verbs: ["get", "list", "watch"]

# Logs - essential for debugging
- apiGroups: [""]
  resources: ["pods/log"]
  verbs: ["get", "list"]

# Networking - read only
- apiGroups: ["networking.k8s.io"]
  resources: ["ingresses", "networkpolicies"]
  verbs: ["get", "list", "watch"]
EOF
```

**Why these permissions?**
- Developers can view pod status, logs, deployments
- Cannot modify anything (no create, update, delete)
- Enough for debugging but not for breaking things

### Step 5.3: Create ClusterRoleBinding
```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: developer-readonly-binding
subjects:
- kind: Group
  name: developers           # ðŸ‘ˆ K8s group name
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: developer-readonly   # ðŸ‘ˆ Links to ClusterRole above
  apiGroup: rbac.authorization.k8s.io
EOF
```

### Step 5.4: Map Developer IAM Role to developers Group

Add to Terraform:
```hcl
# Developer access (example - uncomment and customize)
# resource "aws_eks_access_entry" "developer" {
#   cluster_name      = module.eks.cluster_name
#   principal_arn     = "arn:aws:iam::ACCOUNT:role/DeveloperRole"
#   type              = "STANDARD"
#   kubernetes_groups = ["developers"]  # ðŸ‘ˆ Maps to K8s group
# }
```

---

## Part 6: Using eksctl (Alternative Method)

If you prefer CLI over Terraform:

```bash
# Install eksctl if not installed
# https://eksctl.io/installation/

# Add IAM user as admin
eksctl create iamidentitymapping \
  --cluster techitfactory-dev \
  --region ap-south-1 \
  --arn arn:aws:iam::ACCOUNT:user/jai \
  --username admin \
  --group system:masters

# Add developer IAM role
eksctl create iamidentitymapping \
  --cluster techitfactory-dev \
  --region ap-south-1 \
  --arn arn:aws:iam::ACCOUNT:role/DeveloperRole \
  --username developer \
  --group developers

# List all mappings
eksctl get iamidentitymapping \
  --cluster techitfactory-dev \
  --region ap-south-1
```

---

## Part 7: Verification

### Step 7.1: Test Admin Access
```bash
kubectl auth can-i create pods
# yes

kubectl auth can-i delete namespaces
# yes

kubectl auth can-i '*' '*'
# yes (full admin)
```

### Step 7.2: List Access Entries
```bash
aws eks list-access-entries --cluster-name techitfactory-dev

aws eks describe-access-entry \
  --cluster-name techitfactory-dev \
  --principal-arn "arn:aws:iam::ACCOUNT:user/jai"
```

### Step 7.3: Verify RBAC
```bash
# List ClusterRoles
kubectl get clusterrole | grep developer

# List ClusterRoleBindings
kubectl get clusterrolebinding | grep developer

# Describe the binding
kubectl describe clusterrolebinding developer-readonly-binding
```

---

## Commit and Push

```bash
cd ~/Desktop/Devops-Project/techitfactory-infra
git add .
git commit -m "Configure EKS access entries and developer RBAC"
git push origin main
```

---

## Key Takeaways

1. **Two Methods**: EKS Access Entry (new) vs aws-auth ConfigMap (legacy)
2. **Use Access Entry**: Declarative, no kubectl required, SSO-friendly
3. **RBAC for Fine-Grained Access**: ClusterRole + ClusterRoleBinding
4. **Access Scopes**: Cluster-wide or namespace-specific
5. **Never Lock Yourself Out**: Access Entry can recover access without kubectl

---

## Access Policy Quick Reference

| Policy | Kubernetes Equivalent | Use Case |
|--------|----------------------|----------|
| AmazonEKSClusterAdminPolicy | system:masters | Platform team |
| AmazonEKSAdminPolicy | cluster-admin (no RBAC) | Operators |
| AmazonEKSEditPolicy | edit | Developers |
| AmazonEKSViewPolicy | view | Auditors |

---

## Troubleshooting

### "You must be logged in to the server (Unauthorized)"
```bash
# Re-run kubeconfig update
aws eks update-kubeconfig --name techitfactory-dev --region ap-south-1

# Check your IAM identity
aws sts get-caller-identity
```

### "Error from server (Forbidden)"
```bash
# Check what you can do
kubectl auth can-i --list

# Check your identity
kubectl auth whoami
```

### Locked out of cluster
```bash
# Use AWS Console or Terraform to add access entry
# No kubectl needed!
aws eks create-access-entry \
  --cluster-name techitfactory-dev \
  --principal-arn arn:aws:iam::ACCOUNT:user/admin
```

---

## Next: Story 4.3 (Cluster Autoscaler)
