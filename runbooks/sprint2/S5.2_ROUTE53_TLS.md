# Sprint 2, Story 5.2: Configure Route53 + TLS

## Story Summary
Set up custom domain with Route53 and TLS certificates via AWS Certificate Manager.

**What We're Configuring:**
- Route53 Hosted Zone
- ACM Certificate (TLS)
- DNS validation
- HTTPS Ingress

---

## Prerequisites
- S5.1 completed (ALB Controller running)
- Domain name registered (e.g., techitfactory.com)
- DNS pointed to Route53 (if using external registrar)

---

## Part 1: Create Route53 Hosted Zone

### Step 1.1: Create Hosted Zone (via Terraform)
```hcl
# Add to infrastructure or create modules/dns/main.tf

variable "domain_name" {
  description = "Domain name for the application"
  type        = string
  default     = "techitfactory.com"  # Replace with your domain
}

resource "aws_route53_zone" "main" {
  name = var.domain_name

  tags = {
    Name        = var.domain_name
    Environment = var.environment
  }
}

output "name_servers" {
  description = "Name servers for the hosted zone"
  value       = aws_route53_zone.main.name_servers
}

output "zone_id" {
  description = "Route53 zone ID"
  value       = aws_route53_zone.main.zone_id
}
```

### Step 1.2: Update Domain Registrar (if external)
```bash
# Get name servers
terraform output name_servers

# Update your domain registrar to use these name servers:
# ns-xxx.awsdns-xx.org
# ns-xxx.awsdns-xx.co.uk
# ns-xxx.awsdns-xx.net
# ns-xxx.awsdns-xx.com
```

---

## Part 2: Request ACM Certificate

### Step 2.1: Create ACM Certificate (via Terraform)
```hcl
# ACM Certificate
resource "aws_acm_certificate" "main" {
  domain_name               = var.domain_name
  subject_alternative_names = ["*.${var.domain_name}"]  # Wildcard
  validation_method         = "DNS"

  lifecycle {
    create_before_destroy = true
  }

  tags = {
    Name        = var.domain_name
    Environment = var.environment
  }
}

# DNS Validation Records
resource "aws_route53_record" "cert_validation" {
  for_each = {
    for dvo in aws_acm_certificate.main.domain_validation_options : dvo.domain_name => {
      name   = dvo.resource_record_name
      record = dvo.resource_record_value
      type   = dvo.resource_record_type
    }
  }

  zone_id = aws_route53_zone.main.zone_id
  name    = each.value.name
  type    = each.value.type
  records = [each.value.record]
  ttl     = 60

  allow_overwrite = true
}

# Certificate Validation
resource "aws_acm_certificate_validation" "main" {
  certificate_arn         = aws_acm_certificate.main.arn
  validation_record_fqdns = [for record in aws_route53_record.cert_validation : record.fqdn]
}

output "certificate_arn" {
  description = "ACM certificate ARN"
  value       = aws_acm_certificate.main.arn
}
```

### Step 2.2: Apply and Wait for Validation
```bash
terraform apply

# Validation takes 5-30 minutes
aws acm describe-certificate \
  --certificate-arn $(terraform output -raw certificate_arn) \
  --query "Certificate.Status"
# Should eventually show "ISSUED"
```

---

## Part 3: Create HTTPS Ingress

### Step 3.1: Deploy App with HTTPS Ingress
```bash
# Get certificate ARN
CERT_ARN=$(terraform output -raw certificate_arn)

kubectl apply -f - <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-app
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: hello-app
  template:
    metadata:
      labels:
        app: hello-app
    spec:
      containers:
      - name: hello
        image: hashicorp/http-echo
        args: ["-text=Hello from TechITFactory!"]
        ports:
        - containerPort: 5678
---
apiVersion: v1
kind: Service
metadata:
  name: hello-app
  namespace: default
spec:
  selector:
    app: hello-app
  ports:
  - port: 80
    targetPort: 5678
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hello-app
  namespace: default
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/certificate-arn: ${CERT_ARN}
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
    alb.ingress.kubernetes.io/ssl-redirect: '443'
spec:
  ingressClassName: alb
  rules:
  - host: app.techitfactory.com  # Replace with your subdomain
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: hello-app
            port:
              number: 80
EOF
```

---

## Part 4: Create DNS Record for ALB

### Step 4.1: Get ALB Hostname
```bash
kubectl get ingress hello-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
```

### Step 4.2: Create Route53 Alias Record (via Terraform)
```hcl
# Get the ALB zone ID for your region
# ap-south-1 ALB zone: Z18NTBI3Y7N9TZ

resource "aws_route53_record" "app" {
  zone_id = aws_route53_zone.main.zone_id
  name    = "app.${var.domain_name}"
  type    = "A"

  alias {
    name                   = data.kubernetes_ingress.hello_app.status[0].load_balancer[0].ingress[0].hostname
    zone_id                = "Z18NTBI3Y7N9TZ"  # ALB zone for ap-south-1
    evaluate_target_health = true
  }
}
```

Or manually via CLI:
```bash
ALB_HOSTNAME=$(kubectl get ingress hello-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

aws route53 change-resource-record-sets \
  --hosted-zone-id $(terraform output -raw zone_id) \
  --change-batch '{
    "Changes": [{
      "Action": "UPSERT",
      "ResourceRecordSet": {
        "Name": "app.techitfactory.com",
        "Type": "A",
        "AliasTarget": {
          "HostedZoneId": "Z18NTBI3Y7N9TZ",
          "DNSName": "'${ALB_HOSTNAME}'",
          "EvaluateTargetHealth": true
        }
      }
    }]
  }'
```

---

## Part 5: Install External DNS (Optional)

Automates DNS record creation from Ingress annotations.

### Step 5.1: Create IRSA Role
```bash
eksctl create iamserviceaccount \
  --cluster=techitfactory-dev \
  --namespace=kube-system \
  --name=external-dns \
  --attach-policy-arn=arn:aws:iam::aws:policy/AmazonRoute53FullAccess \
  --approve \
  --region=ap-south-1
```

### Step 5.2: Install via Helm
```bash
helm repo add external-dns https://kubernetes-sigs.github.io/external-dns/
helm repo update

helm install external-dns external-dns/external-dns \
  -n kube-system \
  --set serviceAccount.create=false \
  --set serviceAccount.name=external-dns \
  --set provider=aws \
  --set aws.region=ap-south-1 \
  --set txtOwnerId=techitfactory-dev \
  --set domainFilters[0]=techitfactory.com
```

### Step 5.3: Add Annotation to Ingress
```yaml
annotations:
  external-dns.alpha.kubernetes.io/hostname: app.techitfactory.com
```

---

## Verification

### Test HTTPS Access
```bash
curl -v https://app.techitfactory.com
# Should show TLS handshake and "Hello from TechITFactory!"
```

### Check Certificate
```bash
echo | openssl s_client -connect app.techitfactory.com:443 2>/dev/null | openssl x509 -noout -dates
```

### Check DNS
```bash
dig app.techitfactory.com
nslookup app.techitfactory.com
```

---

## Cost Summary

| Resource | Monthly Cost |
|----------|--------------|
| Route53 Hosted Zone | $0.50 |
| Route53 Queries | ~$0.40/million |
| ACM Certificate | FREE |
| ALB | ~$16 + $0.008/LCU-hour |

---

## Story Completion Checklist
- [ ] Route53 Hosted Zone created
- [ ] Domain registrar updated (if external)
- [ ] ACM Certificate requested
- [ ] Certificate validated (status: ISSUED)
- [ ] HTTPS Ingress created
- [ ] DNS record points to ALB
- [ ] HTTPS access working
- [ ] HTTPâ†’HTTPS redirect working

---

## Epic 5 Complete! ðŸŽ‰

**What we built:**
- AWS Load Balancer Controller for ALB Ingress
- Route53 Hosted Zone for DNS
- ACM Certificate for TLS
- HTTPS access with auto-redirect
- (Optional) External DNS for automation

**Next: Epic 6 (Microservices)**
