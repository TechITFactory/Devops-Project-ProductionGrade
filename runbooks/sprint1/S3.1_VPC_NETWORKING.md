# Sprint 1, Story 3.1: Provision VPC

## Story Summary
Implement the VPC module with multi-AZ networking for EKS.

**What We're Building:**
- VPC with DNS support
- 2 Public Subnets (for ALB, NAT)
- 2 Private Subnets (for EKS nodes)
- Internet Gateway
- Single NAT Gateway (cost-optimized)
- Route Tables

---

## Prerequisites
- S2.1-S2.3 completed (bootstrap + module skeleton)
- AWS credentials configured
- Terraform initialized

---

## Part 0: Verify Prerequisites

### Step 0.1: Verify AWS Credentials
```bash
# Check AWS identity
aws sts get-caller-identity

# Expected output:
# {
#     "UserId": "AIDAXXXXXXXXXX",
#     "Account": "123456789012",
#     "Arn": "arn:aws:iam::123456789012:user/your-user"
# }
```

### Step 0.2: Verify Module Skeleton Exists
```bash
cd ~/Desktop/Devops-Project/techitfactory-infra

# Check folder structure
ls -la modules/vpc/

# Should see:
# main.tf
# variables.tf
# outputs.tf
# README.md

# If not, go back and complete S2.3 first!
```

### Step 0.3: Verify Bootstrap Completed
```bash
cd ~/Desktop/Devops-Project/techitfactory-infra/bootstrap

# Get state bucket name
terraform output state_bucket_name
# Save this value: techitfactory-terraform-state-XXXXXXXX

# Get lock table name  
terraform output lock_table_name
# Save this value: techitfactory-terraform-locks
```

---

## Part 1: Implement VPC Module

### Step 1.1: Navigate to VPC Module
```bash
cd ~/Desktop/Devops-Project/techitfactory-infra/modules/vpc

# Confirm you're in the right directory
pwd
# Should show: /home/YOUR_USER/Desktop/Devops-Project/techitfactory-infra/modules/vpc
```

### Step 1.2: Update main.tf with Implementation
```bash
cat > main.tf << 'EOF'
# =============================================================================
# VPC MODULE - IMPLEMENTATION
# =============================================================================

locals {
  name = "${var.project_name}-${var.environment}"

  common_tags = merge(
    {
      Module      = "vpc"
      Environment = var.environment
    },
    var.tags
  )
}

# Get current AWS region
data "aws_region" "current" {}

# =============================================================================
# VPC
# =============================================================================

resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true  # Required for EKS
  enable_dns_support   = true  # Required for EKS

  tags = merge(local.common_tags, {
    Name = "${local.name}-vpc"
  })
}

# =============================================================================
# INTERNET GATEWAY
# =============================================================================

resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = merge(local.common_tags, {
    Name = "${local.name}-igw"
  })
}

# =============================================================================
# PUBLIC SUBNETS
# =============================================================================

resource "aws_subnet" "public" {
  count = length(var.public_subnets)

  vpc_id                  = aws_vpc.main.id
  cidr_block              = var.public_subnets[count.index]
  availability_zone       = var.azs[count.index]
  map_public_ip_on_launch = true

  tags = merge(local.common_tags, {
    Name                     = "${local.name}-public-${var.azs[count.index]}"
    "kubernetes.io/role/elb" = "1"  # Tag for ALB Controller
    Tier                     = "public"
  })
}

# =============================================================================
# PRIVATE SUBNETS
# =============================================================================

resource "aws_subnet" "private" {
  count = length(var.private_subnets)

  vpc_id            = aws_vpc.main.id
  cidr_block        = var.private_subnets[count.index]
  availability_zone = var.azs[count.index]

  tags = merge(local.common_tags, {
    Name                              = "${local.name}-private-${var.azs[count.index]}"
    "kubernetes.io/role/internal-elb" = "1"  # Tag for internal ALB
    Tier                              = "private"
  })
}

# =============================================================================
# ELASTIC IP FOR NAT GATEWAY
# =============================================================================

resource "aws_eip" "nat" {
  count  = var.single_nat_gateway ? 1 : length(var.azs)
  domain = "vpc"

  tags = merge(local.common_tags, {
    Name = "${local.name}-nat-eip-${count.index + 1}"
  })

  depends_on = [aws_internet_gateway.main]
}

# =============================================================================
# NAT GATEWAY
# =============================================================================

resource "aws_nat_gateway" "main" {
  count = var.single_nat_gateway ? 1 : length(var.azs)

  allocation_id = aws_eip.nat[count.index].id
  subnet_id     = aws_subnet.public[count.index].id

  tags = merge(local.common_tags, {
    Name = "${local.name}-nat-${count.index + 1}"
  })

  depends_on = [aws_internet_gateway.main]
}

# =============================================================================
# PUBLIC ROUTE TABLE
# =============================================================================

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }

  tags = merge(local.common_tags, {
    Name = "${local.name}-public-rt"
  })
}

resource "aws_route_table_association" "public" {
  count = length(var.public_subnets)

  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

# =============================================================================
# PRIVATE ROUTE TABLES
# =============================================================================

resource "aws_route_table" "private" {
  count  = var.single_nat_gateway ? 1 : length(var.azs)
  vpc_id = aws_vpc.main.id

  route {
    cidr_block     = "0.0.0.0/0"
    nat_gateway_id = aws_nat_gateway.main[var.single_nat_gateway ? 0 : count.index].id
  }

  tags = merge(local.common_tags, {
    Name = "${local.name}-private-rt-${count.index + 1}"
  })
}

resource "aws_route_table_association" "private" {
  count = length(var.private_subnets)

  subnet_id      = aws_subnet.private[count.index].id
  route_table_id = aws_route_table.private[var.single_nat_gateway ? 0 : count.index].id
}

# =============================================================================
# S3 VPC ENDPOINT (Gateway - FREE)
# =============================================================================

resource "aws_vpc_endpoint" "s3" {
  count = var.enable_s3_endpoint ? 1 : 0

  vpc_id            = aws_vpc.main.id
  service_name      = "com.amazonaws.${data.aws_region.current.name}.s3"
  vpc_endpoint_type = "Gateway"
  route_table_ids   = concat(
    [aws_route_table.public.id],
    aws_route_table.private[*].id
  )

  tags = merge(local.common_tags, {
    Name = "${local.name}-s3-endpoint"
  })
}
EOF
```

### Step 1.3: Update outputs.tf
```bash
cat > outputs.tf << 'EOF'
# =============================================================================
# VPC MODULE - OUTPUTS
# =============================================================================

output "vpc_id" {
  description = "VPC ID"
  value       = aws_vpc.main.id
}

output "vpc_cidr" {
  description = "VPC CIDR block"
  value       = aws_vpc.main.cidr_block
}

output "private_subnet_ids" {
  description = "Private subnet IDs (for EKS nodes)"
  value       = aws_subnet.private[*].id
}

output "public_subnet_ids" {
  description = "Public subnet IDs (for ALB)"
  value       = aws_subnet.public[*].id
}

output "private_subnet_cidrs" {
  description = "Private subnet CIDR blocks"
  value       = aws_subnet.private[*].cidr_block
}

output "public_subnet_cidrs" {
  description = "Public subnet CIDR blocks"
  value       = aws_subnet.public[*].cidr_block
}

output "nat_gateway_ids" {
  description = "NAT Gateway IDs"
  value       = aws_nat_gateway.main[*].id
}

output "nat_public_ips" {
  description = "NAT Gateway public IPs (for allowlisting)"
  value       = aws_eip.nat[*].public_ip
}

output "internet_gateway_id" {
  description = "Internet Gateway ID"
  value       = aws_internet_gateway.main.id
}

output "azs" {
  description = "Availability zones used"
  value       = var.azs
}
EOF
```

---

## Part 2: Configure Dev Environment

### Step 2.1: Get Bootstrap Values
```bash
cd ~/Desktop/Devops-Project/techitfactory-infra/bootstrap

# Get state bucket name - COPY THIS VALUE
terraform output state_bucket_name
# Example: techitfactory-terraform-state-123456789012

# Get lock table name - COPY THIS VALUE  
terraform output lock_table_name
# Example: techitfactory-terraform-locks

# Get AWS account ID
aws sts get-caller-identity --query Account --output text
# Example: 123456789012
```

### Step 2.2: Navigate to Dev Environment
```bash
cd ~/Desktop/Devops-Project/techitfactory-infra/environments/dev

# Confirm you're in the right directory
pwd
# Should show: /home/YOUR_USER/Desktop/Devops-Project/techitfactory-infra/environments/dev
```

### Step 2.3: Create backend.tf (if not exists)
```bash
# Replace YOUR_BUCKET_NAME and YOUR_ACCOUNT_ID with actual values from Step 2.1
cat > backend.tf << 'EOF'
terraform {
  backend "s3" {
    bucket         = "techitfactory-terraform-state-YOUR_ACCOUNT_ID"
    key            = "environments/dev/terraform.tfstate"
    region         = "ap-south-1"
    encrypt        = true
    dynamodb_table = "techitfactory-terraform-locks"
  }
}
EOF

# IMPORTANT: Edit the file to replace YOUR_ACCOUNT_ID with actual account ID
nano backend.tf
# OR
sed -i 's/YOUR_ACCOUNT_ID/123456789012/g' backend.tf
```

### Step 2.4: Update main.tf with VPC Module
```bash
cat > main.tf << 'EOF'
# =============================================================================
# Dev Environment - Main Configuration
# =============================================================================

terraform {
  required_version = ">= 1.6.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "ap-south-1"

  default_tags {
    tags = {
      Environment = "dev"
      Project     = "TechITFactory"
      ManagedBy   = "Terraform"
    }
  }
}

# =============================================================================
# VPC MODULE
# =============================================================================

module "vpc" {
  source = "../../modules/vpc"

  project_name       = "techitfactory"
  environment        = "dev"
  vpc_cidr           = "10.0.0.0/16"
  azs                = ["ap-south-1a", "ap-south-1b"]
  public_subnets     = ["10.0.1.0/24", "10.0.2.0/24"]
  private_subnets    = ["10.0.10.0/24", "10.0.20.0/24"]
  single_nat_gateway = true   # Cost optimization for dev
  enable_s3_endpoint = true   # FREE - always enable
}
EOF
```

### Step 2.5: Create outputs.tf
```bash
cat > outputs.tf << 'EOF'
# =============================================================================
# Dev Environment - Outputs
# =============================================================================

output "vpc_id" {
  description = "VPC ID"
  value       = module.vpc.vpc_id
}

output "private_subnet_ids" {
  description = "Private subnet IDs (for EKS)"
  value       = module.vpc.private_subnet_ids
}

output "public_subnet_ids" {
  description = "Public subnet IDs (for ALB)"
  value       = module.vpc.public_subnet_ids
}

output "nat_public_ips" {
  description = "NAT Gateway public IPs"
  value       = module.vpc.nat_public_ips
}
EOF
```

### Step 2.6: Verify Files Created
```bash
ls -la
# Should see:
# backend.tf
# main.tf
# outputs.tf

cat backend.tf
# Verify bucket name is correct!
```

---

## Part 3: Apply VPC

### Step 3.1: Initialize Dev Environment
```bash
cd ~/Desktop/Devops-Project/techitfactory-infra/environments/dev
terraform init
```

### Step 3.2: Plan VPC Changes
```bash
terraform plan
# Should show ~12 resources to create:
# - 1 VPC
# - 1 Internet Gateway
# - 2 Public Subnets
# - 2 Private Subnets
# - 1 EIP
# - 1 NAT Gateway
# - 1 Public Route Table + 2 associations
# - 1 Private Route Table + 2 associations
# - 1 S3 Endpoint
```

### Step 3.3: Apply
```bash
terraform apply
# Type 'yes' when prompted
```

### Step 3.4: Verify Outputs
```bash
terraform output
# Note the vpc_id and subnet IDs - needed for EKS
```

---

## Verification

### Check VPC in AWS Console
```bash
# List VPCs
aws ec2 describe-vpcs --filters "Name=tag:Project,Values=TechITFactory" \
  --query "Vpcs[*].{ID:VpcId,CIDR:CidrBlock,Name:Tags[?Key=='Name'].Value|[0]}"

# List Subnets
aws ec2 describe-subnets --filters "Name=vpc-id,Values=<vpc-id>" \
  --query "Subnets[*].{ID:SubnetId,AZ:AvailabilityZone,CIDR:CidrBlock,Name:Tags[?Key=='Name'].Value|[0]}"
```

### Check NAT Gateway
```bash
aws ec2 describe-nat-gateways --filter "Name=vpc-id,Values=<vpc-id>" \
  --query "NatGateways[*].{ID:NatGatewayId,State:State,PublicIP:NatGatewayAddresses[0].PublicIp}"
```

---

## Cost Check
```
VPC: Free
Subnets: Free
Internet Gateway: Free
NAT Gateway: ~$0.045/hour = ~$32/month
Elastic IP: Free (when attached to NAT)
S3 Endpoint: FREE
Data Transfer via NAT: ~$0.045/GB
```

---

## Commit and Push

### Step: Commit Changes
```bash
cd ~/Desktop/Devops-Project/techitfactory-infra
git add modules/vpc/
git add environments/dev/
git commit -m "Implement VPC module with multi-AZ networking"
git push origin main
```

---

## Story Completion Checklist
- [ ] modules/vpc/main.tf implemented
- [ ] modules/vpc/outputs.tf updated
- [ ] environments/dev backend configured
- [ ] VPC module enabled in dev
- [ ] terraform init successful
- [ ] terraform apply successful
- [ ] VPC created in AWS
- [ ] 2 public + 2 private subnets created
- [ ] NAT Gateway running
- [ ] S3 endpoint configured
- [ ] Changes committed and pushed

---

## Next: Story 4.1 (EKS Implementation)
With VPC ready, proceed to implement the EKS module.
